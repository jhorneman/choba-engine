# Design goals

These are the design goals for Choba:

## Simple JavaScript data in and out

Choba takes simple JavaScript objects, and generates simple JavaScript objects. Both the input and output can be read from or written to JSON.

## No state management

Choba doesn't manage state for you. You give it the current dynamic state of the game, it gives you the new scene and the new dynamic state back. How you store that is up to you. You can put it in a database, in the browser's local storage (like Mainframe does), use it with Flux or Redux: whatever you like, it's up to you.

## No built-in style support

Support for styled text and visual representations is essential, but there are also a lot of different ways of handling this. HTML, Markdown, reStructured Text, wiki formats... and that's just for text. Choba's approach is to ignore the topic completely. The text operator just passes through whatever parameter it gets, as long as it can be treated as, and concatenated with, a plain JavaScript string. How that string is rendered, with any style information it might contain, is up to you. Mainframe processes the text generated by Choba and replaces simple style tags with span elements.

Perhaps that won't be the right thing to do in some future scenario. It is possible to add a markdown operator, or to introduce an internal styled text type, and rules to convert from one to the other. But that can be solved when it's needed.

Static non-text data can be extracted from the original scene descriptions. In Mainframe, scene descriptions contain styles. The scenes generated by Choba contain a reference to these descriptions, and that is how I can set the page's body element classes based on the scene, in order to switch backgrounds.

Dynamic scene elements can be handled like options. Operators and types can be added, and then these elements can be generated like any other. But again, that can be solved when it's needed.

## A data format that is easy to interpret, not easy to write

This is counter-intuitive. Shouldn't an interactive storytelling engine be easy to write for? The system as a whole: yes, and I have a lot of ideas for that. But I wanted to keep the engine, the core of the system, very simple.

There are many situations where I could have made the engine smarter, having it infer things from the data so that you need to write less boilerplate. But that would also have meant that the engine code and the possible valid forms of the data would have grown more complex. I have tried to keep the engine and the data format simple, because the data format is meant as an intermediate format. It should not only be simple to read, but also simple to write. It has no syntactic sugar, and that makes it easier to write parsers and converters.

## Scene descriptions are expressions

To build a scene, Choba evaluates an expression in a special run-time language. This language is inspired by Lisp (I don't know enough Lisp to really say more, and yes I know [Greenspun's Tenth Rule of Programming](http://www.c2.com/cgi/wiki?GreenspunsTenthRuleOfProgramming)). Expressions consist of arrays, the first element is the operator, values are typed. Choba's input data format is essentially an abstract syntax tree (AST).

It's not a full language, but it may become more like one in the future. One of my key insights during the making of Mainframe was that if you look at scene building as evaluating an expression, you get a very powerful and flexible system. (The other insight was that we have a lot of tools for analyzing code: could these be used to make writing IF easier? My guess is yes.)

## Open and extensible

I tried to make Choba like a simple set of tools that is easy to understand, rather than like an opaque machine. I expect each game that uses Choba to want to extend it somehow. Choba can be used at multiple levels: from the writer/designer level (although we're not there yet), to the simple programming level, to heavy customization. This is tricky to pull off, and it's generally not a good idea to think too much about the future, so we will see how this works out.

## Functional

I am very familiar with object-oriented programming. Over the last few years I've learned more about functional programming through Python and JavaScript. I decided to use a functional style for Choba in order to promote simplicity and testability. Choba doesn't use prototypes, inheritance, global variables, or singletons, and it has no internal state.

## Well-tested

I didn't have as much experience with automated testing of code as I would like, so with this project I wanted to change that. I don't do test-driven development (TDD), but I made sure to have both the infrastructure (test runners, coverage tools) and the architectural style (functional, see above) to permit easy and effective testing right from the start.